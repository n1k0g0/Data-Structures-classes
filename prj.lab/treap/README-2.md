# Декартово дерево (Treap) 
## Общие сведения

Декартово дерево - это структура данных, объединяющая в себе бинарное дерево поиска и бинарную кучу (отсюда и второе её название: treap (tree+heap)). 

В даной задаче было необходимо реализовать создание декартового дерева, а также подсчет всех элементов дерева, меньших заданного параметра.


 
 #### Реализованные методы

| Метод  | Описание |
| ------------- | ------------- |
| `Treap()`  | Конструктор параметризованный размером буфера |
| `Treap(const Treap &inp)` | Конструктор копирования |
| `~Treap( )`  | Деструктор |
| `queueA& operator=(const queueA &inQ) ` | Оператор присваивания |
| `void insertNode(int x , int priority)` | Добавление элемента в очередь |
| `float sumSmallerThan(const float & x) const` | Просуммировать элементы, меньшие чем параметр |
| `float showAllSmallerThan(const float & x, Node* t, float sum) const` | Показать все элементы, меньшие, чем параметр |
| `void showAll(Node *t) const` | Вывести все элементы дерева |
| `void clear( )` | Зачистить дерево |


Также в лабораторной понадобились некотороые вспомогательные методы:

 #### Дополнительные методы

| Метод  | Описание |
| ------------- | ------------- |
| `int getHeight(Node *r)`  | Получить высоту дерева |
| `Node * getRoot()` | Получить информацию о корне дерева |
| `Node * rotateWithLeftChild(Node * & t) const` | Вращение поддерева |
| `Node * rotateWithRightChild(Node * & t) const` | Вращение поддерева |
| `Node * insertNode(int x, int priority, Node * t)` | Добавить элемент |
| `void deleteNode(const int & x, Node * & t)` | Удалить элемент дерева|
| `void toVectorOfPairs(vector<pair<int,int> > & r, Node * n)` | Записать все данные в вектор |
| `void clear(Node * & t)` | Зачистить дерево |

#### Сравнение результатов с `std::vector`

Данная работа предусматривает сравнение результатов подсчета с использованием декартового дерева и стандартного вектора. Полученные результаты содержатся в тестах в каталоге **testin_myTreap**